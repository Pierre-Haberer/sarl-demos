package io.sarl.demos.factorial.distributed

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle

event Factorial {
	var number : Integer
	var value : Integer
} 

event Calculate { 
	var number : Integer 
} 

event ComputationDone { 
	var result : Integer 
}

event Hello

event Die

capacity Logging {	
	def debug(s: String)
	def info(s: String)
}

skill BasicConsoleLogging implements Logging {
	
	def debug(s: String) {
		println("DEBUG:"+s)
	}
	
	def info(s: String)	 {
		println("INFO:"+s)
	}
}

agent FactorialQueryAgent {
	uses Lifecycle, Behaviors, Logging, DefaultContextInteractions, Schedules
	
	var factValue : int
	
	on Initialize {
		factValue = new Integer(occurrence.parameters.get(0) as String)
		setSkill(Logging,new BasicConsoleLogging());

		info("Auto-detecting FactorialAgent")
		task("discovery-task").every(1000) [
			emit(new Hello)
		]
	}

	on Hello [occurrence.source != defaultAddress] {
		task("discovery-task").cancel
		info("Query sent with number "+factValue)
		emit(new Calculate=>[number=factValue])
	}
		
	on ComputationDone {
		info(factValue+"! = "+occurrence.result)
		emit(new Die)
		killMe
	}
}

agent FactorialAgent {
	uses Lifecycle, Behaviors, Logging, DefaultContextInteractions
	var upto : Integer
	  
	on Initialize {		
		setSkill(Logging,new BasicConsoleLogging());
		info("Factorial initialized")	
	} 

	on Hello [occurrence.source != defaultAddress] {
		emit(new Hello)
	}

	on Factorial [occurrence.number < upto ] {		
		wake(new Factorial => [ number = occurrence.number + 1 ; value = occurrence.value * (occurrence.number+1) ])
	}

	on Factorial [ occurrence.number == upto ] {  
		info("Factorial of " + upto + " is " + occurrence.value)	
		emit(new ComputationDone=>[result=occurrence.value])	
	}
	
	on Calculate {
		this.upto  = new Integer(occurrence.number);
		info("Received Calculate for " + this.upto)   
		wake(new Factorial => [ number = 0 ; value = 1 ])
	}

	on Die {
		killMe
	}

}

